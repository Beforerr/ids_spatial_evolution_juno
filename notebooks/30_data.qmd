---
title: Data Processing (Julia)
---

```{julia}
using Juno: produce_or_load_juno
using Juno.Data
using DimensionalData

n, V, T, r = get_state_data()
jno_sw_params = read_sw_params_csv()
```

```{julia}
using Discontinuity
using Dates
using DataFrames

ds = produce_or_load_juno()
```


```{julia}
using FlexiJoins
using StaticArrays
ds.r = parent(r[Ti(Near(ds.time))])
ds.T = T[Ti(Near(ds.time))] * u"K"

df = dropmissing(ds)

df_sw = innerjoin(
    (ds, jno_sw_params),
    by_pred(x -> x.time .. (x.time + Minute(1)), âˆ‹, :time);
)
@transform! df_sw @byrow begin
    :n = :N_PROTONS_CC
    :V = SA[:V_KMPS, 0, 0] * u"km/s"
    :T = :T_PROTONS_EV * u"eV"
    :r = "5 (Data)"
end
```

Diagnose the missing values

```{julia}
using SPEDAS
using Discontinuity: mva_transform, tanh_model

JunoEvent(df::DataFrame, i) = Event(df[i, :], df.tstart[i], df.tstop[i])
JunoEvent(df::DataFrame) = (i = rand(1:size(df, 1)); @info i; Event(df, i))

B_product = Product(b, tview)

struct FitProduct{F,P} <: Function
    f::F
    param::P
    t0::DateTime
end

function (p::FitProduct)(t0, t1)
    tspan = DateTime(t0):Millisecond(10):DateTime(t1)
    xspan = @. (tspan - p.t0) / Millisecond(1)
    data = p.f.(xspan, Ref(p.param))
    return DimVector(data, Ti(tspan))
end

FitProduct(row) = FitProduct(tanh_model, row.fit_param, row.t_us_ds[1])
FitProduct(df::DataFrame, i) = FitProduct(df[i, :])

struct MVAProduct <: Function
    V
    B
    mva_tspan
end

(p::MVAProduct)(t0, t1) = mva(p.V(t0, t1), p.B(p.mva_tspan...))

function plot_candidate(df::DataFrame, i, toffset=Second(0); kwargs...)
    row = df[i, :]
    B_mva = MVAProduct(B_product, B_product, row.t_us_ds)
    Bl_fit_product = FitProduct(row)

    tmin, tmax = row.tstart, row.tstop
    f = tplot([B_product, B_mva, Bl_fit_product], tmin - toffset, tmax + toffset; kwargs...)
    tlines!(f, collect(row.t_us_ds))
    f
end
```

```{julia}
indices = eachindex(df.grad)[isnan.(df.grad)]
```

```{julia}
# 740, 1508, 4004, 4805
# 3094
for i in [4805]
    display(plot_candidate(df, i))
end
```

```{julia}
using Discontinuity: var_mapping, compute_params!

M = var_mapping(; log_str="", j=:J_m_max_mva, n=:n, B=:B_mag)
maps1 = [M.l_log M.l_norm_log; M.j_log M.j_norm_log]
maps2 = [M.density_log M.B_log; M.beta :V_mag];
let df = vcat(df, df_sw, cols=:intersect)
    color = r_map
    fnames = ["juno_distribution_r", "juno_sw_paramters"]
    # df = subset_by_quantiles(ds, [:L_n_cross, :j0_k, :j0_k_norm])
    df = compute_params!(dropmissing(df))
    spec = data(df) * mapping(; color)
    fs = map([maps1]) do m
        plot_dist(spec, m;
            datalimits=datalimits_f,
            axis,
            figure
        )
    end
    resize_to_layout!.(fs)
    # easy_save.(fnames, fs)
    display.(fs)
end
easy_save("juno_distribution_r_sw")
```